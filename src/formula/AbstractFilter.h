/*
 * Filter.h
 *
 *  Created on: Apr 26, 2014
 *      Author: Manuel Sascha Weiand
 */

#ifndef STORM_FORMULA_ABSTRACTFILTER_H_
#define STORM_FORMULA_ABSTRACTFILTER_H_

#include <vector>
#include <string>
#include "src/formula/AbstractFormula.h"
#include "src/formula/actions/AbstractAction.h"

namespace storm {
namespace property {

/*!
 * This enum contains value indicating which kind of scheduler is to be used
 * for path formulas, i.e. probability or reward queries on nondeterministic models.
 */
enum OptimizingOperator {MINIMIZE, MAXIMIZE, UNDEFINED};

/*!
 * This is the base class for the logic specific filter classes.
 * It provides the logic independent functionality concerning the organization of actions and the optimization operator.
 *
 * The general role of the filter is to twofold.
 *
 * On the one hand it is meant to be the interface between the control and the formulas and modelchecker.
 * It sits one level above the root of the formula tree which is represented by it.
 * This gives a distinct class that can be moved through the control functions, thus encapsulating the formula tree and all its classes.
 *
 * On the other hand, as all modelchecking is initiated through its interface it opens up the opportunity to manipulate the output generated by the modelchecker.
 * The manipulation is done by a series of filter actions which are evaluated after the modelchecker has finished.
 * Each action has a distinct function that ranges from state selection to sorting.
 * The input for the first filter action consists mainly of the modelckecking result.
 * Thereafter, the result of each filter action is used as input for the next filter action until all actions have been executed.
 * The final result is then used to generate the output.
 */
template <class T>
class AbstractFilter {

public:

	/*!
	 * Constructs an empty AbstractFilter.
	 * If a value for the optimization operator is given it will be set accordingly.
	 * Otherwise, it will be undefined. The undefined value is intended for deterministic
	 * models, as the do not need a scheduler resolving the nondeterminism.
	 *
	 * @note If a query is executed on a nondeterministic model using an undefined optimization operator
	 *       the modelchecker will throw an exception.
	 *
	 * @param opt The value of the optimization operator.
	 */
	AbstractFilter(OptimizingOperator opt = UNDEFINED) : opt(opt) {
		// Intentionally left empty.
	}

	/*!
	 * Constructs an AbstractFilter containing only the specified action.
	 *
	 * @note If the shared_ptr to the action is empty (contains a nullptr) the Abstract filter will be created empty.
	 *
	 * @param action The action to be executed during evaluation.
	 * @param opt The value of the optimization operator.
	 */
	AbstractFilter(std::shared_ptr<action::AbstractAction<T>> const & action, OptimizingOperator opt = UNDEFINED) : opt(opt) {
		if(action.get() != nullptr) {
			actions.push_back(action);
		}
	}

	/*!
	 * Constructs an AbstractFilter containing the given vector of actions as action list.
	 * The actions will be executed in ascending order of index.
	 *
	 * @note Any vector entry containing an empty shared_ptr will be ignored. Thus, giving a
	 *       vector of five actions with two empty shared_ptr will result in a AbstractFilter containing three actions.
	 *
	 * @param actions A vector of shared_ptr to the actions to be executed during evaluation.
	 * @param opt The value of the optimization operator.
	 */
	AbstractFilter(std::vector<std::shared_ptr<action::AbstractAction<T>>> const & actions, OptimizingOperator opt = UNDEFINED) {
		// Filter out all nullptr actions.
		// First detect that there is at least one.
		uint_fast64_t emptyCount = 0;
		for(uint_fast64_t i = 0; i < actions.size(); i++) {
			if (actions[i].get() == nullptr) {
				emptyCount++;
			}
		}

		if(emptyCount > 0) {
			// There is at least one nullptr action.
			// Allocate space for the non null actions.
			this->actions.reserve(actions.size() - emptyCount);

			// Fill the vector. Note: For most implementations of the standard there will be no reallocation in the vector while doing this.
			for(auto action : actions){
				if(action.get() != nullptr) {
					this->actions.push_back(action);
				}
			}
		} else {
			this->actions = actions;
		}

		this->opt = opt;
	}

	/*!
	 * The virtual destructor.
	 */
	virtual ~AbstractFilter() {
		// Intentionally left empty.
	}

	/*!
	 * Returns a string representation of the filter.
	 *
	 * @returns A string representing the filter.
	 */
	virtual std::string toString() const {
		std::string desc = "filter(";

		for(auto action : actions) {
			desc += action->toString();
			desc += ", ";
		}

		// Remove the last ", ".
		if(!actions.empty()) {
			desc.pop_back();
			desc.pop_back();
		}

		desc += ")";

		return desc;
	}

	/*!
	 * Appends the given action to the list of actions to be executed during evaluation.
	 *
	 * @note If the argument is an empty shared_ptr nothing will happen.
	 *
	 * @param action A shared pointer to the action to be appended.
	 */
	void addAction(std::shared_ptr<action::AbstractAction<T>> const & action) {
		if(action.get() != nullptr) {
			actions.push_back(action);
		}
	}

	/*!
	 * Removes the last action.
	 */
	void removeAction() {
		actions.pop_back();
	}

	/*!
	 * Returns the action at the specified position.
	 *
	 * @param position The position of the action to be returned within the action list.
	 * @returns A shared pointer to the specified action.
	 */
	std::shared_ptr<action::AbstractAction<T>> getAction(uint_fast64_t position) {
		// Make sure the chosen position is not beyond the end of the vector.
		// If it is so return the last element.
		if(position < actions.size()) {
			return actions[position];
		} else {
			return actions[actions.size()-1];
		}
	}

	/*!
	 * Returns the number of actions to be executed during evaluation.
	 *
	 * @returns The number of actions in the action list.
	 */
	uint_fast64_t getActionCount() const {
		return actions.size();
	}

	/*!
	 * Sets whether a minimizing or a maximizing scheduler is to be used for
	 * modelchecking of path formulas, i.e. probability and reward queries.
	 *
	 * @param opt The new operator specifying the scheduler to be used for path formulas.
	 */
	void setOptimizingOperator(OptimizingOperator opt) {
		this->opt = opt;
	}

	/*!
	 * Returns the current optimization operator.
	 *
	 * @return The optimization operator.
	 */
	OptimizingOperator getOptimizingOperator() const {
		return opt;
	}

protected:

	//! The vector containing the actions to be executed during evaluation.
	std::vector<std::shared_ptr<action::AbstractAction<T>>> actions;

	//! The optimization operator specifying if and which kind of scheduler is to be used during modelchecking of path formulas on nondeterministic models.
	OptimizingOperator opt;
};

} //namespace property
} //namespace storm



#endif /* STORM_FORMULA_ABSTRACTFILTER_H_ */
